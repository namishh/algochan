---
type: page
title: Memory Management for Dummies
tag: Prerequisite
author: Namish
---

## Memory

![mem](https://raw.githubusercontent.com/cat-milk/Anime-Girls-Holding-Programming-Books/master/C/Ai_Hayasaka_Shinomiya_Kaguya_C_Programming_Language.png)

This chapter focuses on getting you familiar with the memory management in C. This is a very important topic as it is the base of all the data structures and algorithms. First, lets see a very basic overview of your application' memory.

![mem](/memory/memory.png)

As discussed in the [previous entry](/pre/pointers), the application memory is divided into 4 segments. The stack, the heap, the static and the code. The stack is used for storing the local variables, the heap is used for dynamic memory allocation, the static is used for storing the global and static variables and the code is used for storing the instructions.

Let us write some demo code to understand the memory management in C.

```c
#include <stdio.h>

int total = 0; // global variable

int square(int x) {
    int y = x * x; // local variable
    return y;
}

int sumofsquares(int a, int b) {
    int x = square(a);
    int y = square(b);
    return x + y;
}

int main() {
    int a = 3, b = 4;
    total = sumofsquares(a, b);
    printf("Total: %d\n", total);
    return 0;
}
```

For this example the memory would look something like this:

![demo](/memory/demo.png)

In the stack, we start from the main function, as the **sumofsquares** function is called, the main stack frame is paused and another stack frame of **sumofsquares** is made.

In the sumofsquares function, the **square** function is called, so another stack frame is made for the **square** function.
<br/>
The **square** function returns the value to the **sumofsquares** function and then the **sumofsquares** function returns the value to the main function. As soon as a function returns a value, its stack frame is popped off the stack.

<br/>
If our call stack grows beyond the given size, it creates a condition called **Stack Overflow** and it will cause the program to crash. This happens frequently when writing bad recursion code.

### Limitations of stack // Heap

1. The stack is of fixed size. It cannot grow during runtime.
2. The allocation and deallocation happens by a fixed rule of appending and popping. It is not possible to manipulate the scope of a variable
3. The stack is not flexible. It is not possible to allocate memory at runtime.

<br/>
Unlike stack, **heap** is not fixed. It's size can vary during the lifetime of the program. Devs get the full control of the memory allocation and deallocation. The heap will **continue to grow** until the system itself runs out of memory (this can be dangerous). The heap is also called the **free store**. Using the heap is also called

### Dynamic Memory Allocation

Now let us take a deep dive at dynamic memory allocation with this code. It _might_ get a bit confusing from here.

```c
int main() {
    int a; // this goes on the stack
    int *p;
    p = (int *)malloc(sizeof(int)); // this goes on the heap

    *p = 37;

    p = (int *)malloc(sizeof(int));
    *p = 45;
}
```
