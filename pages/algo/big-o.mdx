---
type: page
title: The Big O Notation
tag: Algorithms
author: Namish
---

## The Big O Notation

![big-0](/bigo/big-o.png)

### Need For Big O and Time Complexity

Suppose these two codes written in python. Their task is to find the letter `i` in the word inputted by the user.

```py
word = input()
if i in word:
    print("Found i")
```

The second code

```py
word = input()
for letter in word:
    if letter == 'i':
        print("Found i")
```

Now if we were to run the first code on a piece of junk, and second one on a supercomputer, the supercomputer might execute it faster, but in the terms of Big O, the first code is faster. This is because the first code has a time complexity of `O(1)` and the second code has a time complexity of `O(n)`.

<br/>
So, Time Complexity is a way to represent how much time an algorithm takes to run, in terms of the input size. How do we see it mathematically? Well we can plot a graph of the time taken by the algorithm to run, against the input size. This graph is called the Time Complexity Graph. So let us take some example code.

```c
int main() {
    for (int i = 0; i < n; i++) {
        printf("Hello, World!");
    }
}
```

Here we can see that `n` and time are directly proportional. Therefore the graph would look something like this. Theta in the graph is called the rate of increase of time taken by the algorithm. And this rate is referred to as the Time Complexity of the algorithm.

![graph](/bigo/simple-graph.png)

### Big O Notation

Big O Notation is a way to represent the time complexity of an algorithm. It is a mathematical notation that describes the limiting behavior of a function when the argument tends **towards a particular value** or **infinity**. It is used to **describe the upper bound** of the time complexity of an algorithm. It's like saying, "The time complexity of this algorithm **will never be more than this.**" We write as O(x), where x is the time complexity of the algorithm. You just need to remember 3 rules while calculating the Big O of an algorithm.

1. Always consider the worst case scenario.
2. Ignore the constants.
3. Ignore the lower terms.

### Analysis of Insertion Sort

Let us take an example of Insertion Sort. Let us write some pseudo code for it.

```txt
InsertionSort(arr)
    for i = 1 to n
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key
            arr[j + 1] = arr[j]
            j = j - 1
        arr[j + 1] = key
```

It should be obvious as to what the code does. The input of this array is a sequence `(a1, a2, a3 .... an)` and the output is a permutation of the input sequence such that `a1 <= a2 <= a3 .... <= an`.

<br/>

This is how the code actually works. Imagine you have a deck of cards, from `1` to `n`.

1. Start with the first card. It is **"already sorted"** since their is only 1 card.
2. Look at the second card. If it's smaller than the first card, swap them. Now the first two cards are in order.
3. Take the third card. Compare it to the cards before it, and slide it into the right spot. Now the first three cards are in order.
4. Keep doing this for each new card. Take it and slide it back into the right spot among the cards you've already sorted.
5. When you've done this with all the cards, they'll all be in order! This algorithm is called insertion sort because you're inserting each new card into the right spot in the part you've already sorted.

It's C implementation would kinda look like:

```c
#include <stdio.h>

void insertionsort(int arr[], int n) {
    int key, i, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        // So for the first iteration, arr[i] = 2 and arr[j] = 5
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // replace 2 with 5
            j = j - 1;
        }
        arr[j + 1] = key; // old 5 is now 2
    }
}

int main() {
    int arr[] = {5, 2, 4, 6, 1, 3};
    int n = sizeof(arr) / sizeof(arr[0]);
    insertionsort(arr, n);
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
```

Here is a step by step diagram of how the code works.

![insertion example](/bigo/insertion.png)


This was a very easy sorting algorithm to understand and implement.
